---
layout: post
title: Meta Habit
category: Translation
tags: lnek, lnek.github.io
description: MetaHabit

---

在hacknews看到一篇关于优秀工程师习惯的[文章](https://news.ycombinator.com/item?id=14709076) ,就把它翻译过来了.以下是翻译内容:

meta-habit: 针对不同的情况养成不同的习惯.基于这一点,我们能够发现一些有用的技术习惯.

第一部分是数据相关的,我没有进行翻译.

---

当你维护一个庞大的代码库:

1.记得看一看文件大小,越是大的文件越是涵盖了程序中重要的部分,至少是程序重要部分的一个分支.然而main.cc文件通常比较精简,没有办法找到程序的主要逻辑.

2.使用调试器从主循环开始进行单步调试,可以更快理解关于程序处理流程相关的逻辑.

3.查看关键的数据结构,特别是那些作为参数传入到许多函数的数据结构.大多数程序都有关键的数据结构,当我们找到并理解了它们,再整理程序逻辑将会更容易.

4.编写单元测试.这是确认你是否已经完全理解代码是如何工作的最佳方式.

5.可以尝试删除部分代码,然后运行程序,看看是什么地方崩溃了.

---

性能优化相关:
(这里强烈推荐一下性能大神[Brendan D. Gregg](http://brendangregg.com/index.html)的[博客](http://brendangregg.com/blog/index.html))

1.过早的优化是万恶之源.当你已经发布了系统并且用户感知到太慢才需要做.要拥有性能指标来明确你需要优化到什么程度,并且当达到之后,就不需要再做了.

2.做性能优化之前(甚至分析之前),记得建立一个当前系统的各个运行指标的记录,来保证自己的优化没有让系统性能倒退,除非你非常明确此次的倒退是因为陷入了局部最优且非全局最优的情况,并且能够在将来达到超过现在的高度(比如架构调整之类).如果遇到这种情况,需要在VCS中标注,以便在看起来性能变差的情况下结束此次优化.

3.许多性能的瓶颈实际上是在系统之间的接口处.在任何的RPC框架收集时序统计的信息,并且有方法能传播与可视化请求经过每个服务器的时间,以及请求的哪些部分并发,他们的关键路径在哪.

4.profile

5.通常你可以避免一些不必要的工作而达到性能调优的初步指标.缓存消耗较大的计算结果,并且

6.切莫忽略常量,可能时间复杂度较差的算法在实践中会有更好的表象,因为遇到了某一些特定的场景(如基本有序的数列排序,快排的效率就会很差,虽然它的时间复杂度很低).你可以在经常被调用的函数中测试一下.

7.当你有一个profile时,通常可以通过改变你的数据结构来获得非常显著的收益.注意内存的使用:通常内存减少能减少cache压力,从而显著的加速系统运行.但是要注意这个方法的局限性,以及把常用的数据结构放在一起.消除[pointer-chasing](https://stackoverflow.com/questions/19270414/what-is-pointer-chasing-and-how-it-is-related-to-bfs)有利于value containment(这个术语不知道该如何翻译).

---

通用建议:

1.不要过度设计,确保你的每一个feature都是客户所需要的.

2.仔细控制好依赖关系.你为了一个函数而引入一个库可能短时间内会节约时间,但是它会加入非常多的隐患,比如:部署,版泵控制,安全性,日志,以及导致进程意外退出的错误.

3.当你在一个小团队或者是独立开发者时,让问题累积,然后一次性修复(或者新开一个项目).可是当你在一个大团队时,别让问题堆积.代码库应该始终处于一种稳定的状态,能让新加入的开发者理解与修改.这是读写比例的区别,新的项目(通常指创业公司项目)写代码比读代码多的多,因此可读性对于项目影响相对较小.但是一个成熟的项目(通常指大公司的项目)读代码的时间远比写代码的时间多.(如果你缺少用户,资金,日活,你需要像前者那样.这个时候把后者留给代码的阅读者吧.) (我理解为,让后续的人来重构代码)

